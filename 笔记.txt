什么是指针：
指针是程序数据在内存中的地址，而指针变量是用来保存这些地址的变量。
函数指针：
函数指针是指向函数的指针变量。 int (*fun)(int x)

指针函数：
指针函数的落脚点是一个函数，这个函数的返回值是一个指针。
int* fun(int ,int );

函数指针和指针函数的不同点：
1.定义不同：指针函数本质是一个函数，其返回值是一个指针。
函数指针本质是一个指针，其指向一个函数。
2.写法不同
3.用法不同

指针和引用的区别
1.指针有自己的一块空间，而引用只是一个别名
2.使用sizeof看一个指针的大小是4，而应用则是被引用对象的大小。
3.指针可以被初始化为NULL,而引用必须被初始化且必须是一个已有对象的引用。
4.可以有const指针，但是没有const引用。

指针和数组的区别
1.指针保存数据的地址，数组保存数据。
2.指针间接访问数组，首先获得指针的内容，然后将其作为地址，从该地址中提取数据，数组指针访问数据
3.指针通常用于动态的数据结构，数组通常用于固定数目且数据类型相同的元素。

sizeof是一个操作符，而strlen是库函数。
sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为'\0'的字符串作参数。
编译器在编译时就计算出了sizeof的结果，而strlen必须在运行时才能计算出来。
sizeof计算数据类型占内存的大小，strlen计算字符串实际长度。

为什么要内存对齐？
1.平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
2.性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

vector和list的区别
vector和数组类似，拥有一段连续的内存空间，并且起始地址不变。
因此，它能够高效地进行随机存取，时间复杂度是O(1)。
但是，因为其内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，因此时间复杂度为O(n)。
另外，当数组内存空间不够时，会重新申请一块内动空间并进行内存拷贝。
list是由双向链表实现的，因此内存空间是不连续的。
其只能通过指针访问数据，所以list的随机存取效率很低，时间复杂度为O(n)。
不过由于链表自身的特点，能够进行高效的插入和删除。

类的静态成员函数和非静态成员函数区别：
C++会区分两种类型的成员函数：静态成员函数和非静态成员函数。这两者之间的一个重大区别是，静态成员函数不接受隐含的this自变量。所以，它就无法访问自己类的非静态成员。

malloc和new
delete 会调用对象的析构函数,和 new 对应 free 只会释放内存，new 调用构造函数。malloc与 free 是 C++/C 语言的标准库函数，new/delete 是 C++的运算符。它们都可用于申请动态内存和释放内存。对于非内部数据类型的对象而言，光用 maloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 malloc/free。因此 C++语言需要一个能完成动态内存分配和初始化工作的运算符 new，以及一个能完成清理与释放内存工作的运算符 delete。注意 new/delete 不是库函数。

C语言中'#"作用是作为预处理bai命令du，在编译器进行编译之前对源代码做某些转换。

c++函数中那些不能被声明为虚函数的函数？
1.构造函数
2.内联函数
3.静态函数
4.友元函数

宏定义函数与普通函数区别：
1）宏定义函数没有参数类型也不做类型检查，预编译阶段直接进行宏替换。所以对上面的宏定义函数他可以比较不同类型的数据大小，而普通函数则只能比较形参类型的大小。
2）宏定义函数时一定要注意括号的存在和匹配，有时会因为 括号的不存在就会导致函数在计算的时候出现优先级错误的现象继而导致整个程序出错。
3）调用宏定义函数和普通函数生成的指令不同。

子类析构时要调用父类的析构函数吗？
析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了定义一个对象时先调用基类的构造函数、然后调用派生类的构造函数；析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数。

class与struct区别：
struct 的成员默认是公有的，而类的成员默认是私有的。struct 和 class 在其他方面是功能相当的。从感情上讲，大多数的开发者感到类和结构有很大的差别。感觉上结构仅仅象一堆缺乏封装和功能的开放的内存位，而类就象活的并且可靠的社会成员，它有智能服务，有牢固的封装屏障和一个良好定义的接口。既然大多数人都这么认为，那么只有在你的类有很少的方法并且有公有数据（这种事情在良好设计的系统中是存在的!）时，你也许应该使用 struct 关键字，否则，你应该使用 class 关键字。

strcpy与memcpy主要有以下3方面的区别。
1、复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。
2、复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符"\0"才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。
3、用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy

h头文件中的ifndef/define/endif 的作用？
答：防止该头文件被重复引用。

＃i nclude<file.h> 与 ＃i nclude "file.h"的区别？
答：前者是从 Standard Library 的路径寻找和引用 file.h，而后者是从当前工作路径搜寻并引用 file.h。

如何不使用第三个变量来交换两个数的值
1.算术运算符
      int a,b;
      a=10;b=12;
      a=b-a; //a=2;b=12
      b=b-a; //a=2;b=10
      a=b+a; //a=10;b=10
2.使用异或
      int a=10,b=12; //a=1010^b=1100;
      a=a^b; //a=0110^b=1100;
      b=a^b; //a=0110^b=1010;
      a=a^b; //a=1100=12;b=1010;

标准IO和文件IO：
 通过文件I/O读写文件时，每次操作都会执行相关系统调用。这样处理的好处是直接读写实际文件，坏处是频繁的系统调用会增加系统开销，标准I/O可以看成是在文件I/O的基础上封装了缓冲机制。先读写缓冲区，必要时再访问实际文件，从而减少了系统调用的次数。
文件I/O中用文件描述符表现一个打开的文件，可以访问不同类型的文件如普通文件、设备文件和管道文件等。而标准I/O中用FILE（流）表示一个打开的文件，通常只用来访问普通文件。


linux时间片调度
时间片，简单来说就是CPU分配给各个程序的时间，是各个程序从表面上看是同时进行的，而不会造成CPU资源的浪费。

时间片轮转：每个进程被分配一个时间段，称作它 的时间片，即该进程允许运行的时间。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU 当即进行切换。调度程序所要做的就是维护一张就绪进程列表，当进程用完它的时间片后，它被移到队列的末尾。

时间片设得太短会导致过多的进程切换，降低了CPU效率；而设得太长又可能引起对短的交互请求的响应变差。将时间片设为100毫秒通常是一个比较合理的折衷。

Linux内存映射（mmap）
内存映射，简而言之就是将用户空间的一段内存区域映射到内核 空间，映射成功后，用户对这段内存区域的修改可以直接反映到内核空间，相反，内核空间对这段区域的修改也直接反映用户空间。那么对于内核空 间<---->用户空间两者之间需要大量数据传输等操作的话效率是非常高的。
 首先，驱动程序先分配好一段内存，接着用户进程通过库函数mmap()来告诉内核要将多大的内存映射到内核空间，内核经过一系列函数调用后调用对应的驱动 程序的file_operation中的mmap函数，在该函数中调用remap_pfn_range()来建立映射关系。直白一点就是：驱动程序在 mmap()中利用remap_pfn_range()函数将内核空间的一段内存与用户空间的一段内存建立映射关系。

linux tty驱动架构分析

tty core指的是所有tty类型的驱动的顶层架构，它的代码由内核实现，我们无需修改，代码主要分布在drivers/char下的 n_tty.c,tty_io.c等文件中。而tty driver就指具体的设备驱动，比如串口驱动，console驱动等。

tty的架构其实分为三层：
第一层：
tty_core
所有tty类型的驱动的顶层构架，向应用层提供了统一的接口，应用层的read/write等调用首先会到达这里。
第二层：线路规程
不同的tty类型的设备，具有不同的线路规程。这一层也由内核实现
第三层：
具体的tty类型的驱动，由我们实现

僵尸进程：子进程退出，父进程没有回收子进程资源，则子进程变成僵尸进程。
孤儿进程：父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为1号进程init进程，称为init进程领养孤儿进程。